/*****
01 Tarea de Chomper
Autores: Steadman Murillo y Matias Benavidez
IC3002 Análisis Algoritmos 2026
Prof: Jose Helo Guzman
*/

/*
Largo
E: lista
S: Largo de esta
Sera usada para despues hacer funciones que cuenten numeros de 1 hasta la mitad.
Por derecha e izquierda.
*/
largo(lista):=block
(
	if  lista=[] then 
		0
	else
		1 + largo(rest(lista))
);


/*
Encuentra a chomper y devuelve su posicion
E: Lista
S: Posicion empezando en 0 de Chomper
Sera usada para encontrar a Chomper y contar unos de derecha o a la izqueirda.
*/
ChomperFind(lista):=block
(
    [res],
    res:1,
    while lista#[] and first(lista)#R and first(lista)#L and first(lista)#X do
    (
        res: res + 1,
        lista: rest(lista)
    ),
    res
);

/*
Cuenta la cantidad de unos que hay a la derecha de una posicion
E: lista y posicion
S: cantidad de unos a la derecha (pos+1) de la posicion en la lista
Sera utilizada, para contar la cantidad de unos a la derecha de Chomper tras saber su pos
*/
unosDer(lista,pos):=block
(
    [indice,contador],
    indice: pos + 1,
    contador: 0,
    while indice <= largo(lista) do 
    (
        if lista[indice] = 1 then 
            contador: contador+1,
        indice: indice+1
    ),
    contador
);

/*
Cuenta la cantidad de unos que hay a la izquierda de una posicion
E: lista y posicion
S: cantidad de unos a izquierda (pos-1) de la posicion en la lista
Sera utilizada, para contar la cantidad de unos a la derecha de Chomper tras saber su pos
*/
unosIzq(lista,pos):=block
(
    [indice,contador],
    indice: 1,
    contador: 0,
    while indice <= pos-1 do
    (
        if lista[indice] = 1 then 
            contador: contador+1,
        indice: indice+1
    ),
    contador
);

/*
----------------------------------------------------------------------------------------------

Funcion que mueve a Chomper ya sea a la izquierda(L) o derecha(R)
E: lista y direccion
S: simula movimiento al hacer cambios en donde va chomper
Sera usada para junto a prints simular el cambio de Chomper o su movimiento
*/
mover(lista, direccion):=block
(
    [pos],
    pos: ChomperFind(lista),
    lista[pos]: 0,
    if direccion = L then
        lista[pos-1]: L
    else
        lista[pos+1]: R,
    lista
);

/*
Funcion que decide la direccion de chomper
*/
decidirDireccion(lista):=block
(
    [pos, izq, der],
    pos: ChomperFind(lista),
    izq: unosIzq(lista, pos),
    der: unosDer(lista, pos),
    if izq >= der then 
        L 
    else 
        R
);

/*
Funcion que regresa la cantidad de unos que hay segun una direccion
E: lista y direccion
S: cantidad de unos en dicha direccion
Usada para ciclar a chomper hasta que la cantidad de unos sea 0 durante su mov
*/
unosEnDireccion(lista, dir):=block
(
    [pos],
    pos: ChomperFind(lista),
    if dir = L then
        unosIzq(lista, pos)
    else
        unosDer(lista, pos)
);

/*
Funcion que hace la logica principal, y cumplimiento de reglas
E: lista
S: prints hasta que no hayan 1s y estado final de lista
Modifica la lista y muestra prints mientras lo hace, haciendo uso de ciclos y las funciones pasadas, de las formas que se dijo que serian usadas. 
*/
chomper(lista):=block
(
    [pos, dir, dirContraria],
    pos: ChomperFind(lista),

    if unosIzq(lista, pos) + unosDer(lista, pos) = 0 then
    (
        print(lista),
        end
    )
    else
    (
        print(lista),
        
        /* decidir dirección inicial */
        if lista[pos] = X then
        (
            dir: decidirDireccion(lista),
            lista[pos]: dir,
            print(lista)
        )
        else
            dir: lista[pos],
        
        /* moverse en esa dirección */
        while unosEnDireccion(lista, dir) > 0 do
        (
            lista: mover(lista, dir),
            print(lista)
        ),
        
        /* cambiar a X, luego dirección contraria */
        pos: ChomperFind(lista),
        lista[pos]: X,
        print(lista),
        if dir = L then 
            dirContraria: R 
        else 
            dirContraria: L,
        lista[pos]: dirContraria,
        print(lista),
        
        /* moverse en dirección contraria */
        while unosEnDireccion(lista, dirContraria) > 0 do
        (
            lista: mover(lista, dirContraria),
            print(lista)
        ),
        
        /* terminar */
        pos: ChomperFind(lista),
        lista[pos]: X,
        print(lista),
        end
    )
);
